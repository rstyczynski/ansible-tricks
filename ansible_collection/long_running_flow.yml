---
# Test 1: Start async task, wait for completion using native async_status
- name: Test 1 - Controller waits for result (native async)
  hosts: localhost
  gather_facts: true
  tags: [test1, never]
  tasks:
    - name: Execute long-running command with native async
      ansible.builtin.shell: "sleep 10 && echo 'Task completed'"
      async: 30
      poll: 0
      register: long_task

    - name: Save job metadata for tracking
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_save
      vars:
        async_job_save_ansible_job_id: "{{ long_task.ansible_job_id }}"
        async_job_save_host: "{{ inventory_hostname }}"
        async_job_save_job_name: "test1_sleep_task"

    - name: Display job ID
      ansible.builtin.debug:
        msg: "Job saved with ID: {{ async_job_save_job_id }}"

    - name: Wait for task to complete (native async_status)
      ansible.builtin.async_status:
        jid: "{{ long_task.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      retries: 15
      delay: 2

    - name: Display result
      ansible.builtin.debug:
        msg: "Task completed: {{ job_result.stdout }}"

# Test 2: Start async task and exit (playbook ends, task continues)
- name: Test 2 - Controller exits after starting task
  hosts: localhost
  gather_facts: true
  tags: [test2, never]
  tasks:
    - name: Start long-running task with native async
      ansible.builtin.shell: "sleep 60 && date > /tmp/async_test_complete.txt"
      async: 120
      poll: 0
      register: background_task

    - name: Save job for later resume
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_save
      vars:
        async_job_save_ansible_job_id: "{{ background_task.ansible_job_id }}"
        async_job_save_host: "{{ inventory_hostname }}"
        async_job_save_job_name: "test2_background_task"
        async_job_save_metadata:
          test: "test2"
          description: "Exit and resume test"

    - name: Display job ID for resume
      ansible.builtin.debug:
        msg: |
          Job started with ID: {{ async_job_save_job_id }}

          To resume later, run:
          ansible-playbook long_running_flow.yml --tags test3 -e "resume_job_id={{ async_job_save_job_id }}"

# Test 3: Resume and check previously started task
- name: Test 3 - Controller resumes and checks task
  hosts: localhost
  gather_facts: true
  tags: [test3, never]
  vars:
    resume_job_id: ""  # Pass via -e or prompt
  tasks:
    - name: Fail if no job ID provided
      ansible.builtin.fail:
        msg: "Please provide resume_job_id via -e resume_job_id=<job_id>"
      when: resume_job_id == ""

    - name: Load saved job metadata
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_load
      vars:
        async_job_load_job_id: "{{ resume_job_id }}"

    - name: Display loaded job info
      ansible.builtin.debug:
        msg: "Loaded job: {{ async_job_load_job_name }} on host {{ async_job_load_host }}"

    - name: Check job status using native async_status
      ansible.builtin.async_status:
        jid: "{{ async_job_load_ansible_job_id }}"
      register: resumed_job_result
      ignore_errors: true
      delegate_to: "{{ async_job_load_host }}"

    - name: Display job status
      ansible.builtin.debug:
        msg: |
          Job Status:
          - Finished: {{ resumed_job_result.finished | default(false) }}
          - Return Code: {{ resumed_job_result.rc | default('N/A') }}
          - Failed: {{ resumed_job_result.failed | default(false) }}
          {% if resumed_job_result.finished | default(false) %}
          - Output: {{ resumed_job_result.stdout | default('No output') }}
          {% endif %}

    - name: Check if job is still running
      ansible.builtin.debug:
        msg: "Job is still running. Run this playbook again to check status."
      when: not (resumed_job_result.finished | default(false))

# Test 4: Demonstrate host crash detection
- name: Test 4 - Start task for crash simulation
  hosts: localhost
  gather_facts: true
  tags: [test4_start, never]
  tasks:
    - name: Start task that will be "crashed"
      ansible.builtin.shell: "sleep 300"
      async: 600
      poll: 0
      register: crash_test_task

    - name: Save job for crash test
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_save
      vars:
        async_job_save_ansible_job_id: "{{ crash_test_task.ansible_job_id }}"
        async_job_save_host: "{{ inventory_hostname }}"
        async_job_save_job_name: "test4_crash_simulation"

    - name: Instructions for crash simulation
      ansible.builtin.debug:
        msg: |
          Job started with ID: {{ async_job_save_job_id }}

          To simulate crash:
          1. In another terminal, kill the sleep process
          2. Then run: ansible-playbook long_running_flow.yml --tags test4_check -e "crash_job_id={{ async_job_save_job_id }}"

- name: Test 4 - Check crashed task
  hosts: localhost
  gather_facts: true
  tags: [test4_check, never]
  vars:
    crash_job_id: ""
  tasks:
    - name: Load crashed job
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_load
      vars:
        async_job_load_job_id: "{{ crash_job_id }}"

    - name: Attempt to check crashed job
      ansible.builtin.async_status:
        jid: "{{ async_job_load_ansible_job_id }}"
      register: crash_check
      ignore_errors: true

    - name: Display crash detection
      ansible.builtin.debug:
        msg: |
          Crash Detection:
          - Failed: {{ crash_check.failed }}
          - Error: {{ crash_check.msg | default('No error message') }}
          {% if 'could not find job' in (crash_check.msg | default('')) %}
          - Status: JOB LOST (likely crashed or cleaned up)
          {% endif %}

    - name: Assert crash was detected
      ansible.builtin.assert:
        that:
          - crash_check.failed
          - "'could not find job' in crash_check.msg"
        success_msg: "✓ Crash correctly detected - job not found"
        fail_msg: "✗ Expected 'could not find job' error"
      ignore_errors: true
