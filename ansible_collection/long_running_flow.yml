---
# IDEMPOTENT PATTERN: Run this playbook multiple times with same job_name
# First run: Starts task and saves job_id
# Later runs: Loads existing job_id and checks status

- name: Idempotent long-running task
  hosts: localhost
  gather_facts: true
  vars:
    job_name: "my_long_task"  # Change this to run different jobs
  tasks:
    # STEP 1: Try to load existing job
    - name: Try to load existing job by name
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_load
      vars:
        async_job_load_job_name: "{{ job_name }}"

    - name: Display if job was found
      ansible.builtin.debug:
        msg: "Job '{{ job_name }}' {{ 'FOUND - will check status' if async_job_load_found else 'NOT FOUND - will start new task' }}"

    # STEP 2: Start task ONLY if not found
    - name: Start long-running task (only if not exists)
      ansible.builtin.shell: "sleep 30 && echo 'Task completed at' && date"
      async: 60
      poll: 0
      register: new_task
      when: not async_job_load_found

    # STEP 3: Save job if just started
    - name: Save job metadata (only if just started)
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_save
      vars:
        async_job_save_job_name: "{{ job_name }}"
        async_job_save_ansible_job_id: "{{ new_task.ansible_job_id }}"
        async_job_save_host: "{{ inventory_hostname }}"
      when: not async_job_load_found

    # STEP 4: Check status (works for both new and existing jobs)
    - name: Check task status using native async_status
      ansible.builtin.async_status:
        jid: "{{ async_job_load_ansible_job_id if async_job_load_found else new_task.ansible_job_id }}"
      register: job_status
      ignore_errors: true

    # STEP 5: Display results
    - name: Display job status
      ansible.builtin.debug:
        msg: |
          Job: {{ job_name }}
          Status: {{ 'COMPLETED' if job_status.finished | default(false) else 'RUNNING' }}
          {% if job_status.finished | default(false) %}
          Output: {{ job_status.stdout | default('No output') }}
          Return Code: {{ job_status.rc }}
          {% else %}
          Progress: Task still running, run playbook again to check
          {% endif %}
          {% if job_status.failed | default(false) %}
          Error: {{ job_status.msg | default('Unknown error') }}
          {% endif %}

    - name: Next steps
      ansible.builtin.debug:
        msg: |
          {% if not job_status.finished | default(false) %}
          → Run the same playbook again to check status:
            ansible-playbook long_running_flow.yml
          {% else %}
          → Task is complete! Run with different job_name to start another:
            ansible-playbook long_running_flow.yml -e "job_name=another_task"
          {% endif %}

# Example with parameters from command line
- name: Parameterized idempotent task
  hosts: localhost
  gather_facts: true
  tags: [parametrized, never]
  vars:
    job_name: "{{ cli_job_name | default('default_job') }}"
    job_command: "{{ cli_command | default('sleep 60') }}"
    job_timeout: "{{ cli_timeout | default(120) | int }}"
  tasks:
    - name: Load existing job
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_load
      vars:
        async_job_load_job_name: "{{ job_name }}"

    - name: Start task if not found
      ansible.builtin.shell: "{{ job_command }}"
      async: "{{ job_timeout }}"
      poll: 0
      register: task_result
      when: not async_job_load_found

    - name: Save if just started
      ansible.builtin.include_role:
        name: rstyczynski.ansible.async_job_save
      vars:
        async_job_save_job_name: "{{ job_name }}"
        async_job_save_ansible_job_id: "{{ task_result.ansible_job_id }}"
        async_job_save_host: "{{ inventory_hostname }}"
        async_job_save_metadata:
          command: "{{ job_command }}"
          timeout: "{{ job_timeout }}"
      when: not async_job_load_found

    - name: Check status
      ansible.builtin.async_status:
        jid: "{{ async_job_load_ansible_job_id if async_job_load_found else task_result.ansible_job_id }}"
      register: status

    - name: Show result
      ansible.builtin.debug:
        var: status

# Wait loop example - check repeatedly until done
- name: Wait for job completion with retry loop
  hosts: localhost
  gather_facts: true
  tags: [wait_loop, never]
  vars:
    job_name: "wait_loop_task"
  tasks:
    - name: Load or start task
      block:
        - name: Try load
          ansible.builtin.include_role:
            name: rstyczynski.ansible.async_job_load
          vars:
            async_job_load_job_name: "{{ job_name }}"

        - name: Start if not found
          ansible.builtin.shell: "sleep 20 && echo 'Done'"
          async: 60
          poll: 0
          register: new_job
          when: not async_job_load_found

        - name: Save if started
          ansible.builtin.include_role:
            name: rstyczynski.ansible.async_job_save
          vars:
            async_job_save_job_name: "{{ job_name }}"
            async_job_save_ansible_job_id: "{{ new_job.ansible_job_id }}"
            async_job_save_host: "{{ inventory_hostname }}"
          when: not async_job_load_found

    - name: Wait for completion with native async_status
      ansible.builtin.async_status:
        jid: "{{ async_job_load_ansible_job_id if async_job_load_found else new_job.ansible_job_id }}"
      register: result
      until: result.finished
      retries: 15
      delay: 2

    - name: Display final result
      ansible.builtin.debug:
        msg: "Task completed: {{ result.stdout }}"

# Crash detection example
- name: Demonstrate crash detection
  hosts: localhost
  gather_facts: true
  tags: [crash_test, never]
  vars:
    job_name: "crash_test_job"
  tasks:
    - name: Load or start task
      block:
        - name: Try load
          ansible.builtin.include_role:
            name: rstyczynski.ansible.async_job_load
          vars:
            async_job_load_job_name: "{{ job_name }}"

        - name: Start long task (that you'll kill manually)
          ansible.builtin.shell: "sleep 300"
          async: 600
          poll: 0
          register: crash_job
          when: not async_job_load_found

        - name: Save job
          ansible.builtin.include_role:
            name: rstyczynski.ansible.async_job_save
          vars:
            async_job_save_job_name: "{{ job_name }}"
            async_job_save_ansible_job_id: "{{ crash_job.ansible_job_id }}"
            async_job_save_host: "{{ inventory_hostname }}"
          when: not async_job_load_found

        - name: Instructions if just started
          ansible.builtin.debug:
            msg: |
              Task started! To simulate crash:
              1. Find and kill the sleep process: pkill -f "sleep 300"
              2. Run this playbook again with same job_name
          when: not async_job_load_found

    - name: Check status (will detect crash)
      ansible.builtin.async_status:
        jid: "{{ async_job_load_ansible_job_id if async_job_load_found else crash_job.ansible_job_id }}"
      register: crash_status
      ignore_errors: true

    - name: Display crash detection
      ansible.builtin.debug:
        msg: |
          Status Check Results:
          - Failed: {{ crash_status.failed | default(false) }}
          - Finished: {{ crash_status.finished | default(false) }}
          {% if crash_status.failed and 'could not find job' in (crash_status.msg | default('')) %}
          - CRASH DETECTED: Job was lost (process killed or host rebooted)
          {% elif not crash_status.finished %}
          - Job is still running
          {% else %}
          - Job completed normally
          {% endif %}
