---
# LIVE OUTPUT CAPTURE PATTERN: Monitor async task stdout/stderr in real-time
#
# This scenario demonstrates how to capture and monitor live output from
# long-running async tasks. Ansible's native async_status module only
# returns output after task completion, so this example shows the
# file-based capture pattern.
#
# Key Concepts:
# 1. Shell redirection with tee captures output to files
# 2. stdbuf ensures unbuffered (real-time) output
# 3. Monitoring loop reads files periodically
# 4. Display modes: full (all output) or tail (last N lines)
#
# Prerequisites:
# - bash shell (for process substitution)
# - stdbuf utility (GNU coreutils) - recommended for real-time updates
# - tee command (standard on all systems)
#
# Usage:
#   # Run with defaults (tail mode, last 20 lines)
#   ansible-playbook scenario_05_live_output.yml
#
#   # Run with full output display
#   ansible-playbook scenario_05_live_output.yml -e "display_mode=full"
#
#   # Run with custom parameters
#   ansible-playbook scenario_05_live_output.yml \
#     -e "script_duration=60" \
#     -e "script_line_count=20" \
#     -e "monitor_interval=10" \
#     -e "display_mode=tail" \
#     -e "tail_lines=10"
#

- name: Live Output Capture Example
  hosts: localhost
  gather_facts: true
  vars:
    # Job identification (consistent name for idempotency)
    job_name: "live_output_example"  # Change this to run different jobs

    # Script configuration
    script_path: "{{ playbook_dir }}/scripts/generate_output.sh"
    script_duration: 300          # seconds (5 minutes default)
    script_line_count: 50         # number of output lines

    # Output capture configuration
    output_dir: "~/.ansible_async"

    # Display configuration
    display_mode: "tail"          # "full" or "tail"
    tail_lines: 20                # lines to show in tail mode
    monitor_interval: 5           # seconds between monitoring checks

    # Derived variables
    max_retries: "{{ ((script_duration | int) / (monitor_interval | int)) | int + 10 }}"

  tasks:
    # === STEP 1: Setup ===

    - name: Display scenario information
      ansible.builtin.debug:
        msg: |
          ═══════════════════════════════════════════════════════════
          Live Output Capture Scenario
          ═══════════════════════════════════════════════════════════

          Configuration:
            - Script duration: {{ script_duration }} seconds
            - Output lines: {{ script_line_count }}
            - Display mode: {{ display_mode }}
            {% if display_mode == 'tail' -%}
            - Tail lines: {{ tail_lines }}
            {% endif -%}
            - Monitor interval: {{ monitor_interval }} seconds

          Output will be captured to:
            {{ output_dir | expanduser }}/[job_id].stdout
            {{ output_dir | expanduser }}/[job_id].stderr

          ═══════════════════════════════════════════════════════════

    - name: Ensure async output directory exists
      ansible.builtin.file:
        path: "{{ output_dir }}"
        state: directory
        mode: '0700'

    - name: Verify helper script exists
      ansible.builtin.stat:
        path: "{{ script_path }}"
      register: script_check
      failed_when: not script_check.stat.exists
      changed_when: false

    - name: Verify capture wrapper exists
      ansible.builtin.stat:
        path: "{{ playbook_dir }}/scripts/capture_wrapper.sh"
      register: wrapper_check
      failed_when: not wrapper_check.stat.exists
      changed_when: false

    # === STEP 2: Check for existing job (IDEMPOTENCY) ===

    - name: Check for existing job files
      ansible.builtin.find:
        paths: "{{ output_dir }}"
        patterns: "{{ job_name }}_*.stdout"
      register: existing_jobs

    - name: Set job found flag
      ansible.builtin.set_fact:
        job_found: "{{ existing_jobs.files | length > 0 }}"
        existing_job_id: "{{ (existing_jobs.files | first).path | basename | regex_replace('\\.stdout$', '') if existing_jobs.files | length > 0 else '' }}"

    - name: Display job status
      ansible.builtin.debug:
        msg: "Job '{{ job_name }}' {{ 'FOUND - will check status' if job_found else 'NOT FOUND - will start new task' }}"

    - name: Use existing job_id or generate new one
      ansible.builtin.set_fact:
        custom_job_id: "{{ existing_job_id if job_found else (job_name + '_' + ansible_date_time.epoch + '_' + (999999 | random | string)) }}"

    - name: Display job information
      ansible.builtin.debug:
        msg: |
          Job ID: {{ custom_job_id }}

          Output files will be:
            - {{ output_dir | expanduser }}/{{ custom_job_id }}.stdout
            - {{ output_dir | expanduser }}/{{ custom_job_id }}.stderr

          You can monitor in real-time with:
            tail -f {{ output_dir | expanduser }}/{{ custom_job_id }}.stdout
            tail -f {{ output_dir | expanduser }}/{{ custom_job_id }}.stderr

    # === STEP 3: Launch async task with output capture (only if not found) ===

    - name: Launch async task with live output capture (only if not exists)
      ansible.builtin.shell: >
        {{ playbook_dir }}/scripts/capture_wrapper.sh
        {{ custom_job_id }}
        {{ script_path }}
        --duration {{ script_duration }}
        --count {{ script_line_count }}
      async: "{{ script_duration | int + 30 }}"
      poll: 0
      register: new_task
      when: not job_found
      args:
        executable: /bin/bash

    - name: Set async result variable
      ansible.builtin.set_fact:
        async_result: "{{ new_task if not job_found else {'ansible_job_id': 'N/A', 'started': 1} }}"

    - name: Display async job information
      ansible.builtin.debug:
        msg: |
          {% if job_found -%}
          Found existing job!
          {% else -%}
          Async task started successfully!
          {% endif %}

          Custom Job ID: {{ custom_job_id }}
          {% if not job_found -%}
          Ansible Job ID: {{ async_result.ansible_job_id }}
          {% endif %}

          {% if job_found -%}
          Resuming monitoring of existing job...
          {% else -%}
          Task is now running in the background...
          {% endif -%}
          Starting monitoring loop in {{ monitor_interval }} seconds

    # === STEP 4: Wait for output files to be created ===

    - name: Wait for output files to be created
      ansible.builtin.wait_for:
        path: "{{ output_dir | expanduser }}/{{ custom_job_id }}.{{ item }}"
        timeout: 30
      loop:
        - stdout
        - stderr
      loop_control:
        label: "{{ item }}"

    - name: Pause before starting monitoring
      ansible.builtin.pause:
        seconds: "{{ monitor_interval }}"

    # === STEP 5: Monitor task output ===

    - name: Monitor async task output (loop until complete)
      ansible.builtin.include_tasks: monitor_output.yml
      vars:
        monitor_check_index: "{{ item }}"
      loop: "{{ range(0, max_retries | int) | list }}"
      loop_control:
        label: "Monitoring check {{ item + 1 }}"
      when: not (job_status.finished | default(false))

    # === STEP 6: Display final results ===

    - name: Display completion header
      ansible.builtin.debug:
        msg: |
          ═══════════════════════════════════════════════════════════
          Task Completed!
          ═══════════════════════════════════════════════════════════

    - name: Display final task status
      ansible.builtin.debug:
        msg: |
          Job: {{ job_name }}
          Job ID: {{ custom_job_id }}
          {% if not job_found -%}
          Ansible Job ID: {{ async_result.ansible_job_id }}
          {% endif -%}
          Exit Code: {{ job_status.rc | default('N/A') }}
          Status: {{ 'SUCCESS' if (job_status.rc | default(1)) == 0 else 'FAILED' }}

          Output files preserved at:
            - {{ output_dir | expanduser }}/{{ custom_job_id }}.stdout
            - {{ output_dir | expanduser }}/{{ custom_job_id }}.stderr

          You can review the complete output with:
            cat {{ output_dir | expanduser }}/{{ custom_job_id }}.stdout
            cat {{ output_dir | expanduser }}/{{ custom_job_id }}.stderr

    - name: Display next steps
      ansible.builtin.debug:
        msg: |
          ═══════════════════════════════════════════════════════════
          Next Steps
          ═══════════════════════════════════════════════════════════

          Try these variations:

          1. Full output display mode:
             ansible-playbook scenario_05_live_output.yml -e "display_mode=full"

          2. Faster execution (shorter test):
             ansible-playbook scenario_05_live_output.yml \
               -e "script_duration=60" -e "script_line_count=20"

          3. More frequent monitoring:
             ansible-playbook scenario_05_live_output.yml \
               -e "monitor_interval=3"

          4. Custom tail length:
             ansible-playbook scenario_05_live_output.yml \
               -e "display_mode=tail" -e "tail_lines=10"

          5. Different job (runs new task):
             ansible-playbook scenario_05_live_output.yml \
               -e "job_name=another_job"

          Note: Run with same job_name to check status of existing job (idempotent)

          ═══════════════════════════════════════════════════════════
